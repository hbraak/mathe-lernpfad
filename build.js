#!/usr/bin/env node
/**
 * Build-Script: YAML-Aufgaben ‚Üí data.js
 * 
 * Liest alle freigegebenen Unit-Dateien aus units/approved/*.yaml
 * und generiert die data.js f√ºr die App.
 * 
 * Usage: node build.js
 */

const fs = require('fs');
const path = require('path');
const yaml = require('js-yaml');  // npm install js-yaml

const APPROVED_DIR = path.join(__dirname, 'units', 'approved');
const OUTPUT_FILE = path.join(__dirname, 'data.js');

// ---- Load and validate ----
function loadUnits() {
    const files = fs.readdirSync(APPROVED_DIR).filter(f => f.endsWith('.yaml') || f.endsWith('.yml'));
    const units = [];
    
    for (const file of files) {
        const raw = fs.readFileSync(path.join(APPROVED_DIR, file), 'utf8');
        const doc = yaml.load(raw);
        
        // Validate
        if (!doc.unit?.id || !doc.unit?.title) {
            console.error(`‚ùå ${file}: Fehlt unit.id oder unit.title`);
            process.exit(1);
        }
        if (!doc.tasks || !doc.tasks.length) {
            console.error(`‚ùå ${file}: Keine tasks definiert`);
            process.exit(1);
        }
        
        let errors = 0;
        for (const t of doc.tasks) {
            if (!t.id) { console.error(`  ‚ùå ${file}: Task ohne id`); errors++; }
            if (!t.question) { console.error(`  ‚ùå ${file}: ${t.id} ohne question`); errors++; }
            if (t.type === 'choice') {
                if (!t.options) { console.error(`  ‚ùå ${file}: ${t.id} choice ohne options`); errors++; }
                if (t.correct === undefined) { console.error(`  ‚ùå ${file}: ${t.id} choice ohne correct`); errors++; }
            } else {
                if (!t.answer) { console.error(`  ‚ùå ${file}: ${t.id} freitext ohne answer`); errors++; }
            }
            if (!t.hints || t.hints.length < 1) {
                console.warn(`  ‚ö†Ô∏è  ${file}: ${t.id} hat keine Hints`);
            }
        }
        if (errors) process.exit(1);
        
        units.push(doc);
    }
    
    // Sort by order
    units.sort((a, b) => (a.unit.order || 999) - (b.unit.order || 999));
    return units;
}

// ---- Generate data.js ----
function generateDataJS(units) {
    let js = '// ============================================================\n';
    js += '// AUTO-GENERATED by build.js ‚Äî DO NOT EDIT MANUALLY\n';
    js += `// Generated: ${new Date().toISOString()}\n`;
    js += '// ============================================================\n\n';
    js += 'const UNITS = {\n';
    
    for (const doc of units) {
        const u = doc.unit;
        js += `    // --- ${u.title} (${u.bildungsplan?.as ? 'AS ' + u.bildungsplan.as : 'LP' + (u.lernpfad || '?')}) ---\n`;
        js += `    ${JSON.stringify(u.id)}: {\n`;
        js += `        title: ${JSON.stringify(u.title)},\n`;
        js += `        description: ${JSON.stringify(u.description?.trim() || '')},\n`;
        if (u.explanation) {
            js += `        explanation: ${JSON.stringify(u.explanation.trim())},\n`;
        }
        js += `        masteryThreshold: ${u.masteryThreshold || 0.7},\n`;
        js += `        tasks: [\n`;
        
        for (const t of doc.tasks) {
            js += `            {\n`;
            js += `                id: ${JSON.stringify(t.id)},\n`;
            js += `                question: ${JSON.stringify(t.question?.trim() || '')},\n`;
            
            if (t.type === 'choice') {
                js += `                type: "choice",\n`;
                js += `                options: ${JSON.stringify(t.options)},\n`;
                js += `                correct: ${t.correct},\n`;
            } else {
                js += `                answer: ${JSON.stringify(t.answer)},\n`;
                if (t.accepts) js += `                accepts: ${JSON.stringify(t.accepts)},\n`;
            }
            
            if (t.input_mode) js += `                input_mode: ${JSON.stringify(t.input_mode)},\n`;
            if (t.hints) js += `                hints: ${JSON.stringify(t.hints.map(h => h?.trim ? h.trim() : h))},\n`;
            if (t.errorPatterns) js += `                errorPatterns: ${JSON.stringify(t.errorPatterns)}\n`;
            
            js += `            },\n`;
        }
        
        js += `        ]\n`;
        js += `    },\n\n`;
    }
    
    js += '};\n\n';
    
    // Unit order from sorted units
    const order = units.map(u => u.unit.id);
    js += `const UNIT_ORDER = ${JSON.stringify(order)};\n\n`;
    
    // Gemini config (append from template)
    js += `// Gemini API (domain-restricted to hbraak.github.io)\n`;
    js += `const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/openai/chat/completions';\n`;
    js += `const GEMINI_API_KEY = new URLSearchParams(window.location.search).get('key') || '';\n`;
    js += `const GITHUB_TOKEN = new URLSearchParams(window.location.search).get('ghtoken') || '';\n`;
    js += `const GIST_ID = '1adfc536c05ff59f6448fb95dcd3bb92';\n`;
    js += `const GEMINI_MODEL = 'gemini-2.5-flash';\n`;
    
    return js;
}

// ---- Main ----
const units = loadUnits();
console.log(`üì¶ ${units.length} Units geladen:`);
units.forEach(u => console.log(`   ${u.unit.order || '?'}. ${u.unit.title} (${u.tasks.length} Aufgaben)`));

const js = generateDataJS(units);
fs.writeFileSync(OUTPUT_FILE, js, 'utf8');
console.log(`\n‚úÖ data.js generiert (${(js.length/1024).toFixed(1)} KB)`);

// Syntax check
const { execSync } = require('child_process');
try {
    execSync(`node -c ${OUTPUT_FILE}`, { stdio: 'pipe' });
    console.log('‚úÖ Syntax OK');
} catch (e) {
    console.error('‚ùå Syntax-Fehler in generierter data.js!');
    console.error(e.stderr.toString());
    process.exit(1);
}
